{"version":3,"sources":["webpack:///webpack/bootstrap 66f506845079333d29e5","webpack:///./src/scripts/canvasEngine/engine.js","webpack:///./src/scripts/canvasEngine/util.js","webpack:///./src/scripts/resources/sprites.js","webpack:///./src/scripts/canvasEngine/canvas.js","webpack:///./src/scripts/canvasEngine/sceneCtrl.js","webpack:///./src/scripts/canvasEngine/resources.js","webpack:///./src/scripts/resources/model/circuit.js","webpack:///./src/scripts/resources/ui/button.js","webpack:///./src/scripts/canvasEngine/coroutineCtrl.js","webpack:///./src/scripts/canvasEngine/input.js","webpack:///./src/scripts/resources/scenes/test.js","webpack:///./src/scripts/canvasEngine/entity.js","webpack:///./src/scripts/canvasEngine/gameLoop.js","webpack:///./src/scripts/canvasEngine/physics.js","webpack:///./src/scripts/index.js","webpack:///./src/scripts/resources/graphics/circuitGraphic.js","webpack:///./src/scripts/resources/ui/buttonMenu.js","webpack:///./src/scripts/resources/ui/dialog.js","webpack:///./src/scripts/resources/ui/textarea.js","webpack:///./src/scripts/resources/ui/uiController.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;AClCA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB,IAAI,uBAAuB,IAAI,uBAAuB,IAAI,OAAO;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,mBAAmB,eAAe;AAClC;AACA,uBAAuB,kBAAkB;AACzC;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1jBwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AC/BA;AACiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxDA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;AC3B+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,EAAE,IAAI,EAAE;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,EAAE,IAAI,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,KAAK,gBAAgB,YAAY,IAAI,YAAY;AACjF;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C,YAAY,IAAI,YAAY;AACvE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;AAC5C,8CAA8C;AAC9C,+CAA+C;AAC/C,8CAA8C;AAC9C,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,SAAS,qBAAqB,YAAY,IAAI,YAAY,QAAQ,MAAM,IAAI,MAAM;AAClH;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,gBAAgB;;AAE/C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,WAAW;AACvC,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA,SAAS;AACT;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;;AAEA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,iEAAiE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;;AAEA,eAAe,gBAAgB;AAC/B,oCAAoC,GAAG;AACvC;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;AC7dC;;AAED,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;;;;;;;;ACxEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;AC3KoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;AACA,CAAC;;;;;;;;;;AC1JD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uCAAuC,WAAW;AAClD,2BAA2B;AAC3B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;;;;;;;;AC3BiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AChCiB;AACjB;;AAEA;;;;;;;;;;ACHA;AAAA;;AAWC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iB;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;;;ACxLqB;;AAErB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;;AAEA;AACA;AACA,aAAa;AACb,+BAA+B,uBAAuB;AACtD;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;AC7BC;AACD;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1DC;AACD;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;;AClDA;AAAA;;AASC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gCAAgC;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 66f506845079333d29e5","import resources from './resources'\r\nimport canvasCtrl from './canvas'\r\nimport utilCtrl from './util'\r\nimport inputCtrl from './input'\r\nimport sceneCtrl from './sceneCtrl'\r\nimport entityCtrl from './entity'\r\nimport coroutineCtrl from './coroutineCtrl'\r\nimport physics from './physics'\r\n\r\nexport const drawSprite = canvasCtrl.drawSprite\r\nexport const drawText = canvasCtrl.drawText\r\nexport const canvasElement = canvasCtrl.canvasElement\r\n\r\nexport const loadImage = resources.loadImage\r\n\r\nexport const vec2 = utilCtrl.vec2\r\nexport const eventEmitter = utilCtrl.eventEmitter\r\nexport const linkedList = utilCtrl.linkedList\r\nexport const rect = utilCtrl.rect\r\nexport const sin = utilCtrl.sin\r\nexport const cos = utilCtrl.cos\r\n\r\nexport const input = inputCtrl\r\n\r\nexport const setScene = sceneCtrl.setScene\r\nexport const getScene = sceneCtrl.getScene\r\nexport const scene = sceneCtrl.scene\r\n\r\nexport const entity = entityCtrl\r\n\r\nexport const startCoroutine = coroutineCtrl.startCoroutine\r\nexport const stopCoroutine = coroutineCtrl.stopCoroutine\r\n\r\nexport const pointInside = physics.pointInside\r\nexport const collisionAtPoint = physics.collisionAtPoint\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/engine.js\n// module id = 0\n// module chunks = 0","const degToRad = Math.PI/180\r\nconst sin = (x) => Math.sin(x*degToRad)\r\nconst cos = (x) => Math.cos(x*degToRad)\r\n\r\nconst randomRange = (a, b) => Math.random()*(b - a) + a\r\nconst randomInt = (a, b) => Math.round(randomRange(a, b))\r\nconst randomPick = (...items) => items[randomInt(0, items.length-1)]\r\n\r\n//object composition\r\nconst compose = (target, components, def = {}) => {\r\n    let res = merge(target, def)\r\n    components.forEach(c =>  {\r\n        merge(res, c(res))\r\n    })\r\n    return res\r\n}\r\n\r\n//merging objects\r\nconst merge = (target, ...sources) => {\r\n    sources.forEach(source => {\r\n        if (!source) {\r\n            return\r\n        }\r\n        Object.keys(source).forEach(key => {\r\n            let sourceVal = source[key]\r\n            if (isObject(sourceVal)) {\r\n                if (target[key] === undefined) {\r\n                    target[key] = Object.create(sourceVal)\r\n                }\r\n                target[key] = merge(target[key], sourceVal)\r\n            } else if (isArray(sourceVal)) {\r\n                if (target[key] === undefined) {\r\n                    target[key] = sourceVal.slice()\r\n                }\r\n            } else {\r\n                if (target[key] === undefined) {\r\n                    target[key] = sourceVal\r\n                }\r\n            }\r\n        })\r\n    })\r\n    return target\r\n}\r\n\r\nconst isObject = (obj) => {\r\n    return !!(obj && obj !== null && typeof(obj) === 'object')\r\n}\r\n\r\nconst isArray = Array.isArray\r\n\r\n//clone object\r\nObject.prototype.clone = function(obj) {\r\n    return merge({}, obj)\r\n}\r\n\r\n\r\n//Hashset\r\nconst hashSet = (() => {\r\n    function HashSet() {\r\n        this.items = {}\r\n        this.length = 0\r\n        this.lastHash = 0\r\n    }\r\n    HashSet.prototype.push = function(key, value) {\r\n        this.items[key] = value\r\n        this.length++\r\n        return key\r\n    }\r\n    HashSet.prototype.remove = function(key) {\r\n        delete this.items[key]\r\n        this.length--\r\n    }\r\n    HashSet.prototype.getHash = function() {\r\n        return this.lastHash++\r\n    }\r\n    HashSet.prototype.forEach = function(fn) {\r\n        Object.keys(this.items).forEach(key => fn(this.items[key]))\r\n    }\r\n    return () => new HashSet()\r\n})()\r\n\r\n\r\n//Doubly linked list\r\nconst linkedList = (() => {\r\n    function LinkedList() {\r\n        this.first = null\r\n        this.last = null\r\n        this.length = 0\r\n    }\r\n    function ListNode(value, prev, next) {\r\n        this.value = value\r\n        this.prev = prev\r\n        this.next = next\r\n    }\r\n    LinkedList.prototype.push = function(value) {\r\n        let newNode = new ListNode(value, this.last, null)\r\n\r\n        if (this.first == null) {\r\n            this.first = newNode\r\n        } else {\r\n            this.last.next = newNode\r\n        }\r\n        this.last = newNode\r\n        this.length++\r\n        return newNode\r\n    }\r\n    LinkedList.prototype.remove = function(toRemove) {\r\n        let prev = toRemove.prev\r\n        let next = toRemove.next\r\n\r\n        if (prev != null) {\r\n            prev.next = next\r\n        } else {\r\n            this.first = next\r\n        }\r\n\r\n        if (next != null) {\r\n            next.prev = prev\r\n        } else {\r\n            this.last = prev\r\n        }\r\n        this.length--\r\n    }\r\n    LinkedList.prototype.forEach = function(callback) {\r\n        for (let curr = this.last; curr != null; curr = curr.prev) {\r\n            callback(curr.value, curr)\r\n        }\r\n    }\r\n    LinkedList.prototype.find = function(callback) {\r\n        for (let curr = this.last; curr != null; curr = curr.prev) {\r\n            if (callback(curr.value)) {\r\n                return curr.value\r\n            }\r\n        }\r\n    }\r\n    return () => new LinkedList()\r\n})()\r\n\r\n// Event emitter\r\n\r\nconst eventEmitter = () => {\r\n    let subscribers = linkedList()\r\n\r\n    return {\r\n        subscribe: (sub) => subscribers.push(sub),\r\n        unsubscribe: (index) => subscribers.remove(index),\r\n        notify: (...args) => {\r\n            subscribers.forEach(sub => {\r\n                if (sub) {\r\n                    sub(...args)\r\n                }\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//Vector2\r\nconst vec2 = (() => {\r\n    function Vec2(x, y) {\r\n        this.x = x\r\n        this.y = y\r\n    }\r\n    Vec2.prototype.len = function() {\r\n        return Math.sqrt(this.x**2 + this.y**2)\r\n    }\r\n    Vec2.prototype.unit = function() {\r\n        let l = this.len()\r\n        if (l == 0) {\r\n            return new Vec2(0, 0)\r\n        }\r\n        return new Vec2(this.x/l, this.y/l)\r\n    }\r\n    Vec2.prototype.add = function(other) {\r\n        return new Vec2(this.x + other.x, this.y + other.y)\r\n    }\r\n    Vec2.prototype.sub = function(other) {\r\n        return new Vec2(this.x - other.x, this.y - other.y)\r\n    }\r\n    Vec2.prototype.mult = function(n) {\r\n        return new Vec2(this.x*n, this.y*n)\r\n    }\r\n    Vec2.prototype.copy = function() {\r\n        return new Vec2(this.x, this.y)\r\n    }\r\n    Vec2.prototype.dot = function(other) {\r\n        return this.x*other.x + this.y*other.y\r\n    }\r\n    Vec2.prototype.proj = function(other) {\r\n        return other.mult(this.dot(other)/Math.sqr(other.len()))\r\n    }\r\n    Vec2.prototype.rotate = function(angle) {\r\n        return new Vec2(\r\n            this.x*cos(angle) + this.y*sin(angle),\r\n            this.x*sin(angle) + this.y*cos(angle)\r\n        )\r\n    }\r\n    Vec2.prototype.normal = function() {\r\n        return new Vec2(-this.y, this.x)\r\n    }\r\n    Vec2.prototype.translate = function(other) {\r\n        this.x += other.x\r\n        this.y += other.y\r\n    }\r\n    Vec2.prototype.round = function() {\r\n        return new Vec2(Math.round(this.x), Math.round(this.y))\r\n    }\r\n\r\n    let result = (x = 0, y = 0) => new Vec2(x, y)\r\n    //static methods\r\n    result.zero = () => {\r\n        return new Vec2(0, 0)\r\n    }\r\n    result.right = () => {\r\n        return new Vec2(1, 0)\r\n    }\r\n    result.up = () => {\r\n        return new Vec2(0, 1)\r\n    }\r\n    result.left = () => {\r\n        return new Vec2(-1, 0)\r\n    }\r\n    result.down = () => {\r\n        return new Vec2(0, -1)\r\n    }\r\n    return result\r\n})()\r\n\r\nconst rect = (() => {\r\n    function Rect(left, top, right, bottom) {\r\n        this.left = left\r\n        this.top = top\r\n        this.right = right\r\n        this.bottom = bottom\r\n    }\r\n    return (left, top, right, bottom) => new Rect(left, top, right, bottom)\r\n})()\r\n\r\n//Stack\r\nconst stack = (() => {\r\n    function Stack() {\r\n        this.last = null\r\n        this.length = 0\r\n    }\r\n    function StackNode(value, prev) {\r\n        this.value = value\r\n        this.prev = prev\r\n    }\r\n    Stack.prototype.push = function(value) {\r\n        let newNode = new StackNode(value, this.last)\r\n        this.last = newNode\r\n        this.length++\r\n    }\r\n    Stack.prototype.pop = function() {\r\n        if (!this.last) {\r\n            return null\r\n        }\r\n        let result = this.last.value\r\n        this.last = this.last.prev\r\n        this.length--\r\n        return result\r\n    }\r\n    Stack.prototype.peek = function() {\r\n        if (!this.last) {\r\n            return null\r\n        }\r\n        return this.last.value\r\n    }\r\n    return () => new Stack()\r\n})()\r\n\r\n//repeat\r\nconst repeat = (fn, times) => {\r\n    for (let i = 0; i < times; i++) {\r\n        fn()\r\n    }\r\n}\r\n\r\n//enum\r\nconst enumCreate = (...items) => {\r\n    let e = {}\r\n    items.forEach((item, i) => {\r\n        e[item] = i\r\n    })\r\n    return Object.freeze(e)\r\n}\r\n\r\n\r\n//color\r\nconst color = (() => {\r\n    function Color(r, g, b, a = 1) {\r\n        this.r = r\r\n        this.g = g\r\n        this.b = b\r\n        this.a = a\r\n    }\r\n    Color.prototype.toString = function() {\r\n        return `rgba(${Math.round(this.r*255)}, ${Math.round(this.g*255)}, ${Math.round(this.b*255)}, ${this.a})`\r\n    }\r\n    Color.prototype.toFloat32 = function() {\r\n        return new Float32Array([this.r, this.g, this.b, this.a])\r\n    }\r\n    Color.prototype.add = function(other) {\r\n        return new Color(this.r + other.r, this.g + other.g, this.b + other.g, this.a + other.a)\r\n    }\r\n    return () => new Color()\r\n})()\r\n\r\n\r\n//assertions\r\nconst assert = (expr) => {\r\n    if (!expr) {\r\n        console.log('Assertion failed!')\r\n    }\r\n}\r\n\r\n//vectors and matrices\r\nArray.init = function(length, filler = 0) {\r\n    for (var i = 0, a = new Array(length); i < length;) {\r\n        a[i++] = filler\r\n    }\r\n    return a\r\n}\r\n\r\nconst mat = (height, width) => {\r\n    let m = []\r\n    for (let i = 0; i < height; i++) {\r\n        m[i] = Array.init(width)\r\n    }\r\n    return m\r\n}\r\n\r\nmat.convert = function(source) {\r\n    let height = source.length\r\n    if (height === undefined) {\r\n        return [[source]]\r\n    }\r\n    let width = source[0].length\r\n    if (width === undefined) {\r\n        return [source]\r\n    }\r\n    return source\r\n}\r\n\r\nmat.simplify = function(source) {\r\n    let m\r\n    let height = source.length\r\n    let width = source[0].length\r\n    if (height === 1) {\r\n        if (width === 1) {\r\n            m = source[0][0]\r\n        } else {\r\n            m = source[0]\r\n        }\r\n    } else {\r\n        if (width === 1) {\r\n            m = []\r\n            for (let i = 0; i < height; i++) {\r\n                m[i] = source[i][0]\r\n            }\r\n        } else {\r\n            m = source\r\n        }\r\n    }\r\n    return m\r\n}\r\n\r\nmat.trans = function(source, simplify = true) {\r\n    source = mat.convert(source)\r\n    let m = []\r\n    for (let i = 0; i < source[0].length; i++) {\r\n        m[i] = []\r\n        for (let j = 0; j < source.length; j++) {\r\n            m[i][j] = source[j][i]\r\n        }\r\n    }\r\n    if (simplify) {\r\n        return mat.simplify(m)\r\n    }\r\n    return m\r\n}\r\n\r\nmat.dot = function(m1, m2) {\r\n    m1 = mat.convert(m1, false)\r\n    m2 = mat.convert(m2, false)\r\n\r\n    if (m1[0].length === m2[0].length) {\r\n        if (m2.length === 1) {\r\n            m2 = mat.trans(m2)\r\n        } else if (m1.length === 1) {\r\n            m1 = mat.trans(m1)\r\n        }\r\n    }\r\n\r\n    if (m1.length !== m2.length) {\r\n        if (m1.length === m2[0].length) {\r\n            let temp = m1\r\n            m1 = m2\r\n            m2 = temp\r\n        } else {\r\n            console.log('Incorrect mat width or length!')\r\n        }\r\n    }\r\n\r\n    let m = []\r\n\r\n    for (let i = 0; i < m1.length; i++) {\r\n        m[i] = []\r\n        for (let j = 0; j < m2[0].length; j++) {\r\n            m[i][j] = 0\r\n            for (let k = 0; k < m1[0].length; k++) {\r\n                m[i][j] += m1[i][k]*m2[k][j]\r\n            }\r\n        }\r\n    }\r\n    return mat.simplify(m)\r\n}\r\n\r\nlet deferStack = stack()\r\n\r\nconst defer = (fn) => {\r\n    deferStack.push(fn)\r\n}\r\n\r\nconst out = (value) => {\r\n    for (let next = deferStack.pop(); next !== null; next = deferStack.pop()) {\r\n        next()\r\n    }\r\n    return value\r\n}\r\n\r\nconst tree = (state = {}) => {\r\n    return merge(state, {\r\n        root: null,\r\n        node: (value) => ({\r\n            value,\r\n            parent: null,\r\n            children: []\r\n        }),\r\n        addChild: (parent, child) => {\r\n            if (child.children === undefined) {\r\n                child = state.node(child)\r\n            }\r\n            if (!parent) {\r\n                state.root = child\r\n                return child\r\n            }\r\n            parent.children.push(child)\r\n            child.parent = parent\r\n            return child\r\n        },\r\n        forwardPass: (fn) => {\r\n            const forw = (n) => {\r\n                if (n === null) {\r\n                    return\r\n                }\r\n                fn(n.value)\r\n                n.children.forEach(ch => {\r\n                    forw(ch)\r\n                })\r\n            }\r\n            forw(state.root)\r\n        },\r\n        backwardPass: (fn) => {\r\n            const backw = (n) => {\r\n                if (n === null) {\r\n                    return\r\n                }\r\n                n.children.forEach(ch => {\r\n                    backw(ch)\r\n                })\r\n                fn(n.value)\r\n            }\r\n            backw(state.root)\r\n        }\r\n    })\r\n}\r\n\r\nconst binTree = (state = {}) => {\r\n    return merge(state, {\r\n        root: null,\r\n        node: (value) => ({\r\n            value: value,\r\n            parent: null,\r\n            left: null,\r\n            right: null\r\n        }),\r\n        addChild: (parent, child) => {\r\n            if (child.parent === undefined) {\r\n                child = state.node(child)\r\n            }\r\n            if (!parent) {\r\n                state.root = child\r\n                return child\r\n            }\r\n            child.parent = parent\r\n            return child\r\n        },\r\n        addLeft: (parent, child) => {\r\n            child = state.addChild(parent, child)\r\n            if (parent) {\r\n                parent.left = child\r\n            }\r\n            return child\r\n        },\r\n        addRight: (parent, child) => {\r\n            child = state.addChild(parent, child)\r\n            if (parent) {\r\n                parent.right = child\r\n            }\r\n            return child\r\n        },\r\n        forwardPass: (fn) => {\r\n            const forw = (n) => {\r\n                if (n === null) {\r\n                    return\r\n                }\r\n                fn(n.value)\r\n                forw(n.left)\r\n                forw(n.right)\r\n            }\r\n            forw(state.root)\r\n        },\r\n        backwardPass: (fn) => {\r\n            const backw = (n) => {\r\n                if (n === null) {\r\n                    return\r\n                }\r\n                backw(n.left)\r\n                backw(n.right)\r\n                fn(n.value)\r\n            }\r\n            backw(state.root)\r\n        },\r\n        symmetricPass: (fn) => {\r\n            const symm = (n) => {\r\n                if (n === null) {\r\n                    return\r\n                }\r\n                symm(n.left)\r\n                fn(n.value)\r\n                symm(n.right)\r\n            }\r\n            symm(state.root)\r\n        }\r\n    })\r\n}\r\n\r\nexport default {\r\n    degToRad,\r\n    sin,\r\n    cos,\r\n    randomRange,\r\n    randomInt,\r\n    randomPick,\r\n    compose,\r\n    hashSet,\r\n    eventEmitter,\r\n    linkedList,\r\n    vec2,\r\n    repeat,\r\n    enumCreate,\r\n    color,\r\n    assert,\r\n    defer,\r\n    out,\r\n    tree,\r\n    binTree,\r\n    stack,\r\n    rect\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/util.js\n// module id = 1\n// module chunks = 0","import {loadImage, vec2} from '../canvasEngine/engine'\r\n\r\nexport default {\r\n    inputMachine: loadImage('img/input.png', vec2(32, 32)),\r\n    outputMachine: loadImage('img/output.png', vec2(32, 32)),\r\n    summatorMachine: loadImage('img/summator.png', vec2(32, 32)),\r\n    subtractorMachine: loadImage('img/subtractor.png', vec2(32, 32)),\r\n    repeaterMachine: loadImage('img/repeater.png', vec2(32, 32)),\r\n    incrementMachine: loadImage('img/increment.png', vec2(32, 32)),\r\n    decrementMachine: loadImage('img/decrement.png', vec2(32, 32)),\r\n    wireStraight: loadImage('img/wire_straight.png', vec2(32, 32)),\r\n    memoryMachine: loadImage('img/memory.png', vec2(32, 32)),\r\n\r\n    data: loadImage('img/data.png', vec2(32, 32)),\r\n    selectRect: loadImage('img/selectRect.png', vec2(32, 32)),\r\n    deleteSign: loadImage('img/deleteSign.png', vec2(32, 32)),\r\n\r\n    buttonEmpty: loadImage('img/button_long.png', vec2(0, 0)),\r\n    buttonPlay: loadImage('img/button_play.png', vec2(0, 0)),\r\n    buttonPause: loadImage('img/button_pause.png', vec2(0, 0)),\r\n    buttonPrevious: loadImage('img/button_previous.png', vec2(0, 0)),\r\n    buttonNext: loadImage('img/button_next.png', vec2(0, 0)),\r\n    buttonStop: loadImage('img/button_stop.png', vec2(0, 0)),\r\n    buttonWire: loadImage('img/button_wire.png', vec2(0, 0)),\r\n    buttonDelete: loadImage('img/button_delete.png', vec2(0, 0)),\r\n    grid: loadImage('img/grid.png', vec2(0, 0)),\r\n\r\n    dialog: loadImage('img/dialog.png', vec2(0, 0)),\r\n    dialogButton: loadImage('img/dialog_button.png', vec2(0, 0)),\r\n    dialogInput: loadImage('img/dialog_input.png', vec2(0, 0)),\r\n    buttonSave: loadImage('img/button_save.png', vec2(0, 0)),\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/sprites.js\n// module id = 2\n// module chunks = 0","import util from './util'\r\nimport {getScene} from './engine'\r\n\r\nconst canvas = document.getElementById('gameCanvas')\r\nconst ctx = canvas.getContext('2d')\r\n\r\nwindow.canvas = canvas\r\n\r\nctx.textAlign = 'center'\r\nctx.textBaseline = 'middle'\r\n\r\nconst clear = (color) => {\r\n    ctx.fillStyle = color\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n}\r\n\r\nconst drawQueue = []\r\n\r\nconst queueType = {\r\n    SPRITE: 0,\r\n    TEXT: 1\r\n}\r\n\r\nconst drawSprite = ({\r\n    sprite,\r\n    position,\r\n    angle = 0,\r\n    scale = util.vec2(1, 1),\r\n    layer = 0,\r\n    GUI = false,\r\n    alpha = 1\r\n}) => {\r\n    if (!drawQueue[layer]) {\r\n        drawQueue[layer] = util.linkedList()\r\n    }\r\n    drawQueue[layer].push({\r\n        sprite,\r\n        position,\r\n        angle,\r\n        scale,\r\n        layer,\r\n        GUI,\r\n        alpha,\r\n        type: queueType.SPRITE\r\n    })\r\n}\r\n\r\nconst drawText = ({\r\n    text,\r\n    position,\r\n    angle = 0,\r\n    fontSize = 10,\r\n    font = 'Arial',\r\n    color = 'white',\r\n    layer = 0,\r\n    scale = {x: 1, y: 1},\r\n    GUI = false\r\n}) => {\r\n    if (!drawQueue[layer]) {\r\n        drawQueue[layer] = util.linkedList()\r\n    }\r\n    drawQueue[layer].push({\r\n        text,\r\n        position,\r\n        angle,\r\n        font,\r\n        color,\r\n        layer,\r\n        scale,\r\n        GUI,\r\n        fontSize,\r\n        type: queueType.TEXT\r\n    })\r\n}\r\n\r\nconst clearDrawQueue = () => {\r\n    for (let i = 0; i < drawQueue.length; i++) {\r\n        drawQueue[i] = 0\r\n    }\r\n}\r\n\r\nconst executeDrawQueue = () => {\r\n    const camera = getScene().camera\r\n\r\n    ctx.save()\r\n    ctx.translate(-camera.position.x, -camera.position.y)\r\n    ctx.scale(camera.zoom, camera.zoom)\r\n    for (let i = 0; i < drawQueue.length; i++) {\r\n        if (drawQueue[i]) {\r\n            drawQueue[i].forEach(item => {\r\n                ctx.save()\r\n                ctx.translate(item.position.x, item.position.y)\r\n                ctx.rotate(-item.angle*util.degToRad)\r\n                ctx.scale(item.scale.x, item.scale.y)\r\n                if (item.GUI) {\r\n                    ctx.translate(camera.position.x, camera.position.y)\r\n                    ctx.scale(1/camera.zoom, 1/camera.zoom)\r\n                }\r\n                ctx.globalAlpha = item.alpha\r\n                if (item.type === queueType.SPRITE) {\r\n                    ctx.drawImage(item.sprite.image, -item.sprite.offset.x, -item.sprite.offset.y)\r\n                } else {\r\n                    ctx.fillStyle = item.color\r\n                    ctx.font = item.fontSize + 'px ' + item.font\r\n                    ctx.fillText(item.text, 0, 0)\r\n                }\r\n                ctx.restore()\r\n            })\r\n        }\r\n    }\r\n    ctx.restore()\r\n}\r\n\r\nexport default {\r\n    drawSprite,\r\n    clear,\r\n    width: canvas.width,\r\n    height: canvas.height,\r\n    canvasElement: canvas,\r\n    clearDrawQueue,\r\n    executeDrawQueue,\r\n    drawText\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/canvas.js\n// module id = 3\n// module chunks = 0","import util from './util'\r\nimport canvas from './canvas'\r\nimport gameLoop from './gameLoop'\r\nimport resources from './resources'\r\n\r\nlet currentScene = null\r\n\r\nconst scene = (state) => {\r\n    return util.compose(state, [], {\r\n        width: 100,\r\n        height: 100,\r\n        entities: util.linkedList(),\r\n        onInit() {},\r\n        bgColor: 'black',\r\n        camera: {\r\n            position: util.vec2(),\r\n            size: util.vec2(canvas.canvasElement.width, canvas.canvasElement.height),\r\n            zoom: 1\r\n        }\r\n    })\r\n}\r\n\r\nconst setScene = (scene) => {\r\n    const loadScene = () => {\r\n        if (currentScene) {\r\n            scene.entities.forEach(e => e.destroy())\r\n        }\r\n        currentScene = scene\r\n        scene.onInit()\r\n        console.log('Scene loaded!')\r\n    }\r\n    if (!gameLoop.isRunning()) {\r\n        resources.resourcesLoadedEvent.subscribe(loadScene)\r\n    } else {\r\n        loadScene()\r\n    }\r\n}\r\n\r\nconst runScene = () => {\r\n    if (currentScene) {\r\n        canvas.clear(currentScene.bgColor)\r\n        currentScene.entities.forEach((e) => {\r\n            if (e.enabled) {\r\n                e.onUpdate()\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nconst getScene = () => currentScene\r\n\r\nexport default {\r\n    scene,\r\n    getScene,\r\n    setScene,\r\n    runScene\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/sceneCtrl.js\n// module id = 4\n// module chunks = 0","import util from './util'\r\n\r\nconst resourcesLoadedEvent = util.eventEmitter()\r\n\r\nconst loadQueue = util.linkedList()\r\n\r\nconst loadImage = (url, offset = util.vec2(), layer = 0) => {\r\n    const img = new Image()\r\n    img.src = url\r\n    let index = loadQueue.push(img)\r\n    img.onload = () => {\r\n        console.log(`${url} loaded!`)\r\n        loadQueue.remove(index)\r\n        if (loadQueue.length === 0) {\r\n            resourcesLoadedEvent.notify()\r\n        }\r\n    }\r\n    return {\r\n        image: img,\r\n        offset,\r\n        layer\r\n    }\r\n}\r\n\r\nexport default {\r\n    loadImage,\r\n    resourcesLoadedEvent\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/resources.js\n// module id = 5\n// module chunks = 0","import {eventEmitter, sin, cos} from '../../canvasEngine/engine'\r\n\r\nArray.prototype.peek = function() {\r\n    return this[this.length-1]\r\n}\r\n\r\nconst rotateVec = (x, y, angle) => {\r\n    return [\r\n        Math.round(x*cos(angle) + y*sin(angle)),\r\n        Math.round(-x*sin(angle) + y*cos(angle))\r\n    ]\r\n}\r\n\r\nwindow.rotateVec = rotateVec\r\n\r\nconst circuit = (width, height) => {\r\n    const c = {}\r\n    c.width = width\r\n    c.height = height\r\n    c.tiles = []\r\n    c.states = []\r\n    c.machines = []\r\n\r\n    //allocating tiles\r\n    for (let x = 0; x < c.width; x++) {\r\n        c.tiles[x] = []\r\n        for (let y = 0; y < c.height; y++) {\r\n            c.tiles[x][y] = {\r\n                port: null,\r\n                machine: null,\r\n                x,\r\n                y\r\n            }\r\n        }\r\n    }\r\n\r\n    c.getTileAt = (x, y) => {\r\n        if (x < 0 || x >= c.width || y < 0 || y >= c.height) {\r\n            //console.error(`Tile index out of bounds (${x}, ${y})`)\r\n            return null\r\n        }\r\n        return c.tiles[x][y]\r\n    }\r\n\r\n    //setting up state\r\n    c.getState = () => c.states.peek()\r\n\r\n    c.createState = () => {\r\n        const newState = new Map(c.states.peek())\r\n        if (c.states.peek()) {\r\n            newState.inputData = c.states.peek().inputData\r\n            newState.outputData = c.states.peek().outputData\r\n        }\r\n        c.states.push(newState)\r\n        return newState\r\n    }\r\n\r\n    c.onPortCreated = eventEmitter()\r\n\r\n    //ports\r\n    c.createPort = (x, y, angle = 0) => {\r\n        while (angle >= 360) {\r\n            angle -= 360\r\n        }\r\n        while (angle < 0) {\r\n            angle += 360\r\n        }\r\n        const tile = c.getTileAt(x, y)\r\n        if (tile) {\r\n            if (tile.machine) {\r\n                console.error(`There is a machine already at (${x}, ${y})!`)\r\n                return null\r\n            }\r\n            if (tile.port) {\r\n                c.deletePort(x, y)\r\n            }\r\n        }\r\n        tile.port = {\r\n            angle,\r\n            tile\r\n        }\r\n        c.ports.push(tile.port)\r\n        c.onPortCreated.notify(tile.port)\r\n        return tile.port\r\n    }\r\n\r\n    c.ports = []\r\n\r\n    c.onPortDeleted = eventEmitter()\r\n\r\n    c.deletePort = (x, y) => {\r\n        const tile = c.getTileAt(x, y)\r\n        if (tile && tile.port) {\r\n            c.onPortDeleted.notify(tile.port)\r\n            tile.port = null\r\n            let index = c.ports.indexOf(tile.port)\r\n            c.ports.splice(index, 1)\r\n        }\r\n    }\r\n\r\n    c.getDataAt = (port, state) => {\r\n        const data = state.get(port)\r\n        if (data === undefined) {\r\n            return null\r\n        }\r\n        return data\r\n    }\r\n\r\n    c.setDataAt = (port, state, data) => {\r\n        if (data === null) {\r\n            state.delete(port)\r\n            return\r\n        }\r\n        state.set(port, data)\r\n    }\r\n\r\n    c.onDataCreated = eventEmitter()\r\n\r\n    c.createDataAt = (port, data) => {\r\n        // console.log(`Data (${data}) created at (${port.tile.x}, ${port.tile.y})`)\r\n        c.setDataAt(port, c.getState(), data)\r\n        c.onDataCreated.notify(port)\r\n    }\r\n\r\n    c.onDataDeleted = eventEmitter()\r\n\r\n    c.deleteDataAt = (port) => {\r\n        // console.log(`Data deleted at (${port.tile.x}, ${port.tile.y})`)\r\n        let existingData = c.getDataAt(port, c.getState())\r\n        if (existingData || existingData === 0) {\r\n            c.onDataDeleted.notify(port)\r\n            c.setDataAt(port, c.getState(), null)\r\n        } else {\r\n            console.error('The data is already deleted here!')\r\n        }\r\n    }\r\n\r\n    c.onDataTransfer = eventEmitter()\r\n\r\n    c.transferData = (port, oldState, newState) => {\r\n        if (port.isInPort) {\r\n            return false\r\n        }\r\n\r\n        let nextX, nextY\r\n\r\n        switch(port.angle) {\r\n            case 0: [nextX, nextY] = [1, 0]; break\r\n            case 90: [nextX, nextY] = [0, -1]; break\r\n            case 180: [nextX, nextY] = [-1, 0]; break\r\n            case 270: [nextX, nextY] = [0, 1]; break\r\n            default: console.error(`Wrong angle ${port.angle}!`)\r\n        }\r\n        nextX += port.tile.x\r\n        nextY += port.tile.y\r\n        const nextTile = c.getTileAt(nextX, nextY)\r\n        if (!nextTile) {\r\n            return false\r\n        }\r\n        const nextPort = nextTile.port\r\n\r\n        if (!nextPort || c.getDataAt(nextPort, oldState) !== null || c.getDataAt(nextPort, newState) !== null) {\r\n            return false\r\n        }\r\n\r\n        const prevData = c.getDataAt(port, oldState)\r\n        c.setDataAt(nextPort, newState, prevData)\r\n        c.setDataAt(port, newState, null)\r\n        // console.log(`Data (${prevData}) transfered from (${port.tile.x}, ${port.tile.y}) to (${nextX}, ${nextY})`)\r\n        c.onDataTransfer.notify(port, nextPort)\r\n        return true\r\n    }\r\n\r\n    //stepping forward and backward\r\n    c.stepForward = () => {\r\n        // console.log(`Step ${c.states.length}:`)\r\n\r\n        const oldState = c.getState()\r\n        const newState = c.createState()\r\n\r\n        let transferAmount = 0\r\n\r\n        for (let port of oldState.keys()) {\r\n            if (c.transferData(port, oldState, newState)) {\r\n                transferAmount++\r\n            }\r\n        }\r\n\r\n        for (let machine of c.machines) {\r\n            if (machine.checkReady(oldState)) {\r\n                if (machine.processFunc(oldState, machine.inPorts, machine.outPorts, machine, c) !== false) {\r\n                    transferAmount++\r\n                    machine.clearPorts()\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transferAmount === 0) {\r\n            c.inputMachines.forEach(m => {\r\n                m.isProcessing = false\r\n            })\r\n\r\n            c.states.pop()\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    c.outputMachineCount = 0\r\n    c.inputMachineCount = 0\r\n\r\n    c.stepBackward = () => {\r\n        if (c.states.length === 1) {\r\n            return\r\n        }\r\n\r\n        for (let port of c.getState().keys()) {\r\n            c.deleteDataAt(port)\r\n        }\r\n\r\n        c.states.pop()\r\n\r\n        for (let it of c.getState()) {\r\n            let [port, data] = it\r\n            c.createDataAt(port, data)\r\n        }\r\n\r\n        // console.log('Step backward')\r\n    }\r\n\r\n    c.fullCycle = (inputData) => {\r\n        for (let i = 0; i < inputData.length; i++) {\r\n            c.setInputData([inputData[i]], i)\r\n        }\r\n\r\n        while(c.stepForward()) {\r\n            //\r\n        }\r\n\r\n        let outputData = []\r\n        for (let i = 0; i < c.outputMachineCount; i++) {\r\n            outputData.push(c.getOutputData(c.getState(), i)[0])\r\n        }\r\n\r\n        return outputData\r\n    }\r\n\r\n    c.reset = () => {\r\n        for (let port of c.getState().keys()) {\r\n            c.deleteDataAt(port)\r\n        }\r\n        c.states = [c.states[0]]\r\n    }\r\n\r\n    const cycleGridPositions = (x, y, width, height, fn) => {\r\n        let startX = Math.min(x, x+width-1*Math.sign(width))\r\n        let endX = Math.max(x, x+width-1*Math.sign(width))\r\n        let startY = Math.min(y, y+height-1*Math.sign(height))\r\n        let endY = Math.max(y, y+height-1*Math.sign(height))\r\n\r\n        //check if we can plant the machine here\r\n        for (let i = startX; i <= endX; i++) {\r\n            for (let j = startY; j <= endY; j++) {\r\n                if (!fn(i, j)) {\r\n                    return false\r\n                }\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    //machine\r\n    c.createMachine = (x, y, angle, type) => {\r\n        let inPorts = []\r\n        let outPorts = []\r\n        const createInPort = (xx, yy) => {\r\n            let [newX, newY] = rotateVec(xx, yy, angle)\r\n            let port = c.createPort(x+newX, y+newY, angle)\r\n            port.isInPort = true\r\n            inPorts.push(port)\r\n            return port\r\n        }\r\n        const createOutPort = (xx, yy) => {\r\n            let [newX, newY] = rotateVec(xx, yy, angle)\r\n            let port = c.createPort(x+newX, y+newY, angle)\r\n            port.isOutPort = true\r\n            outPorts.push(port)\r\n            return port\r\n        }\r\n\r\n        let machineType = c.machineTypes[type]\r\n\r\n        let maxPorts = Math.max(machineType.inPortsAmount, machineType.outPortsAmount)\r\n\r\n        let width = (machineType.inPortsAmount && machineType.outPortsAmount) ? 2 : 1\r\n        let height = maxPorts * 2 - 1\r\n\r\n        let [gridWidth, gridHeight] = rotateVec(width, height, angle)\r\n\r\n        if (!cycleGridPositions(x, y, gridWidth, gridHeight, (i, j) => {\r\n            let tile = c.getTileAt(i, j)\r\n            if (!tile || (tile && (tile.machine))) {\r\n                console.error('Cannot create a machine here')\r\n                return false\r\n            }\r\n            return true\r\n        })) {\r\n            return false\r\n        }\r\n\r\n        //creating in and out ports\r\n        for (let i = 0; i < height; i++) {\r\n            if (maxPorts === machineType.inPortsAmount) {\r\n                createInPort(0, i)\r\n            }\r\n            if (maxPorts === machineType.outPortsAmount) {\r\n                createOutPort(width-1, i)\r\n            }\r\n            i++\r\n        }\r\n\r\n        if (\r\n            machineType.inPortsAmount < machineType.outPortsAmount &&\r\n            machineType.inPortsAmount &&\r\n            machineType.inPortsAmount !== maxPorts\r\n        ) {\r\n            let start = Math.ceil((height - (machineType.inPortsAmount*2-1))/2)\r\n            for (let i = start; i < height-start; i++) {\r\n                createInPort(0, i++)\r\n            }\r\n        } else if (machineType.outPortsAmount && machineType.outPortsAmount !== maxPorts) {\r\n            let start = Math.ceil((height - (machineType.outPortsAmount*2-1))/2)\r\n            for (let i = start; i < height-start; i++) {\r\n                createOutPort(width-1, i++)\r\n            }\r\n        }\r\n\r\n        const checkReady = (oldState) => {\r\n            for (let i = 0; i < outPorts.length; i++) {\r\n                if (c.getDataAt(outPorts[i], oldState) !== null) {\r\n                    return false\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < inPorts.length; i++) {\r\n                if (c.getDataAt(inPorts[i], oldState) === null) {\r\n                    return false\r\n                }\r\n            }\r\n\r\n            return true\r\n        }\r\n\r\n        const clearPorts = () => {\r\n            for (let i = 0; i < inPorts.length; i++) {\r\n                c.deleteDataAt(inPorts[i])\r\n            }\r\n        }\r\n\r\n        const tile = c.getTileAt(x, y)\r\n\r\n        const m = {\r\n            tile,\r\n            angle,\r\n            type,\r\n            processFunc: machineType.processFunc,\r\n            inPorts,\r\n            outPorts,\r\n            checkReady,\r\n            clearPorts,\r\n            width,\r\n            height,\r\n            sprite: machineType.sprite,\r\n            gridWidth,\r\n            gridHeight,\r\n            x, y\r\n        }\r\n        c.machines.push(m)\r\n\r\n        cycleGridPositions(x, y, gridWidth, gridHeight, (i, j) => {\r\n            let tile = c.getTileAt(i, j)\r\n            tile.machine = m\r\n            return true\r\n        })\r\n\r\n        if (machineType.onInit) {\r\n            machineType.onInit(m, c)\r\n        }\r\n\r\n        c.onMachineCreated.notify(m)\r\n\r\n        return m\r\n    }\r\n    c.onMachineCreated = eventEmitter()\r\n\r\n    c.deleteMachine = (x, y) => {\r\n        let tile = c.getTileAt(x, y)\r\n        if (tile && tile.machine) {\r\n            let m = tile.machine\r\n            cycleGridPositions(m.x, m.y, m.gridWidth, m.gridHeight, (i, j) => {\r\n                let tile = c.getTileAt(i, j)\r\n                tile.machine = null\r\n                c.deletePort(tile.x, tile.y)\r\n                return true\r\n            })\r\n            c.onMachineDeleted.notify(m)\r\n            let index = c.machines.indexOf(m)\r\n            c.machines.splice(index, 1)\r\n        }\r\n    }\r\n    c.onMachineDeleted = eventEmitter()\r\n\r\n    c.inputMachines = []\r\n\r\n    c.machineTypes = {}\r\n\r\n    c.createState()\r\n\r\n    c.setInputData = (inputData, index) => {\r\n        let state = c.getState()\r\n        if (!state.inputData) {\r\n            state.inputData = []\r\n        }\r\n        state.inputData = state.inputData.slice()\r\n        state.inputData[index] = inputData\r\n    }\r\n\r\n    c.getInputData = (state, index) => {\r\n        let data = state.inputData[index]\r\n        return data\r\n    }\r\n\r\n    c.setOutputData = (outputData, index) => {\r\n        let state = c.getState()\r\n        if (!state.outputData) {\r\n            state.outputData = []\r\n        }\r\n        state.outputData = state.outputData.slice()\r\n        state.outputData[index] = outputData\r\n    }\r\n\r\n    c.getOutputData = (state, index) => {\r\n        return state.outputData[index]\r\n    }\r\n\r\n    c.defineMachine = ({name, inPortsAmount, outPortsAmount, processFunc, sprite, onInit}) => {\r\n        c.machineTypes[name] = {\r\n            inPortsAmount,\r\n            outPortsAmount,\r\n            processFunc,\r\n            sprite,\r\n            onInit\r\n        }\r\n    }\r\n\r\n    c.save = () => {\r\n        let ports = c.ports\r\n            .filter(p => !p.tile.machine)\r\n            .map(port => ({\r\n                x: port.tile.x,\r\n                y: port.tile.y,\r\n                angle: port.angle\r\n            }))\r\n        let machines = c.machines.map(machine => ({\r\n            x: machine.tile.x,\r\n            y: machine.tile.y,\r\n            angle: machine.angle,\r\n            type: machine.type\r\n        }))\r\n        return {ports, machines}\r\n    }\r\n\r\n    c.load = ({ports, machines}) => {\r\n        for (let p = c.ports.peek(); p; p = c.ports.peek()) {\r\n            c.deletePort(p.tile.x, p.tile.y)\r\n        }\r\n        for (let m = c.machines.peek(); m; m = c.machines.peek()) {\r\n            c.deleteMachine(m.x, m.y)\r\n        }\r\n        ports.forEach(p => c.createPort(p.x, p.y, p.angle))\r\n        machines.forEach(m => c.createMachine(m.x, m.y, m.angle, m.type))\r\n    }\r\n\r\n    return c\r\n}\r\n\r\nexport default circuit\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/model/circuit.js\n// module id = 6\n// module chunks = 0","import {\r\n    entity,\r\n    input,\r\n    pointInside,\r\n    drawSprite,\r\n    drawText,\r\n    getScene,\r\n    rect,\r\n    vec2\r\n} from '../../canvasEngine/engine'\r\n\r\nconst button = (state = {}) => {\r\n    let result = entity({\r\n        text: '',\r\n        sprite: null,\r\n        onClick() {\r\n            console.log('im clicked')\r\n        },\r\n        onUpdate: buttonUpdate,\r\n        color: 'red',\r\n        offset: vec2(32, 32)\r\n    })\r\n    Object.assign(result, state)\r\n    if (state.sprite) {\r\n        result.collider = {\r\n            rect: rect(0, 0, state.sprite.image.width, state.sprite.image.height),\r\n            offset: state.sprite.offset.mult(-1),\r\n            GUI: true\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nconst buttonUpdate = function() {\r\n    if (\r\n        input.mouseUp(input.mouse.LEFT) &&\r\n        pointInside(this, input.mouseWorldPosition())\r\n    ) {\r\n        this.onClick()\r\n    }\r\n    if (\r\n        input.mousePressed(input.mouse.LEFT) &&\r\n        pointInside(this, input.mouseWorldPosition())\r\n    ) {\r\n        drawSprite({\r\n            sprite: this.sprite,\r\n            position: this.position,\r\n            layer: getScene().layers.UI,\r\n            GUI: true,\r\n            alpha: 0.7\r\n        })\r\n    } else {\r\n        drawSprite({\r\n            sprite: this.sprite,\r\n            position: this.position,\r\n            layer: getScene().layers.UI,\r\n            GUI: true\r\n        })\r\n    }\r\n    if (this.text) {\r\n        drawText({\r\n            text: this.text,\r\n            position: this.position.add(this.offset),\r\n            fontSize: 18,\r\n            font: 'Arial',\r\n            color: this.color,\r\n            layer: getScene().layers.UI_TEXT,\r\n            GUI: true\r\n        })\r\n    }\r\n}\r\n\r\nexport default button\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/ui/button.js\n// module id = 7\n// module chunks = 0","import util from './util'\r\n\r\nconst runningCoroutines = util.linkedList()\r\n\r\nconst startCoroutine = (gen) => {\r\n    return runningCoroutines.push(gen())\r\n}\r\n\r\nconst stopCoroutine = (cor) => runningCoroutines.remove(cor)\r\n\r\nconst executeCoroutines = () => {\r\n    runningCoroutines.forEach((gen, i) => {\r\n        let iter = gen.next()\r\n        if (iter.done) {\r\n            runningCoroutines.remove(i)\r\n        }\r\n    })\r\n}\r\n\r\nexport default {\r\n    startCoroutine,\r\n    stopCoroutine,\r\n    executeCoroutines\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/coroutineCtrl.js\n// module id = 8\n// module chunks = 0","import util from './util'\r\nimport canvasCtrl from './canvas'\r\nimport sceneCtrl from './sceneCtrl'\r\n\r\nconst keysPressed = []\r\nconst keysDown = []\r\nconst keysUp = []\r\n\r\ndocument.oncontextmenu = (e) => {\r\n    e.preventDefault()\r\n}\r\n\r\nlet keyString = []\r\n\r\ndocument.onkeydown = (e) => {\r\n    if (e.key !== 'Backspace') {\r\n        if (\r\n            e.keyCode === 32 ||\r\n            (e.keyCode >= 48 && e.keyCode <= 58) ||\r\n            (e.keyCode >= 65 && e.keyCode <= 89)\r\n        ) {\r\n            keyString.push(e.key)\r\n        }\r\n    } else {\r\n        keyString.pop()\r\n    }\r\n    if (!keysPressed[e.keyCode]) {\r\n        keysDown[e.keyCode] = true\r\n    }\r\n    keysPressed[e.keyCode] = true\r\n}\r\n\r\ndocument.onkeyup = (e) => {\r\n    keysPressed[e.keyCode] = false\r\n    keysUp[e.keyCode] = true\r\n}\r\n\r\nconst buttonsPressed = []\r\nconst buttonsDown = []\r\nconst buttonsUp = []\r\n\r\nconst rect = canvasCtrl.canvasElement.getBoundingClientRect()\r\nlet mPosition = util.vec2()\r\n\r\nconst mousePosition = () => mPosition\r\n\r\ndocument.onmousemove = (e) => {\r\n    mPosition = util.vec2(\r\n        e.clientX - rect.left,\r\n        e.clientY - rect.top\r\n    )\r\n    return false\r\n}\r\n\r\ndocument.onmousedown = (e) => {\r\n    e.preventDefault()\r\n    if (!buttonsPressed[e.button]) {\r\n        buttonsDown[e.button] = true\r\n    }\r\n    buttonsPressed[e.button] = true\r\n    return false\r\n}\r\n\r\ndocument.onmouseup = (e) => {\r\n    buttonsPressed[e.button] = false\r\n    buttonsUp[e.button] = true\r\n}\r\n\r\nconst clearKeys = () => {\r\n    for (let i = 0; i < keysDown.length; i++) {\r\n        keysDown[i] = false\r\n    }\r\n    for (let i = 0; i < keysUp.length; i++) {\r\n        keysUp[i] = false\r\n    }\r\n    for (let i = 0; i < buttonsDown.length; i++) {\r\n        buttonsDown[i] = false\r\n    }\r\n    for (let i = 0; i < buttonsUp.length; i++) {\r\n        buttonsUp[i] = false\r\n    }\r\n}\r\n\r\nconst keyDown = (k) => keysDown[k]\r\nconst keyUp = (k) => keysUp[k]\r\nconst keyPressed = (k) => keysPressed[k]\r\n\r\nconst mouseDown = (b) => buttonsDown[b]\r\nconst mouseUp = (b) => buttonsUp[b]\r\nconst mousePressed = (b) => buttonsPressed[b]\r\n\r\nconst mouse = {\r\n    LEFT: 0,\r\n    RIGHT: 2\r\n}\r\n\r\nconst keyCode = {\r\n    SPACE: 32,\r\n    ENTER: 13,\r\n    TAB: 9,\r\n    ESC: 27,\r\n    BACKSPACE: 8,\r\n    SHIFT: 16,\r\n    CTRL: 17,\r\n    ALT: 18,\r\n    CAPS_LOCK: 20,\r\n    NUM_LOCK: 144,\r\n    TOP_1: 49,\r\n    TOP_2: 50,\r\n    TOP_3: 51,\r\n    TOP_4: 52,\r\n    TOP_5: 53,\r\n    TOP_6: 54,\r\n    TOP_7: 55,\r\n    TOP_8: 56,\r\n    TOP_9: 57,\r\n    TOP_0: 58,\r\n    LEFT: 37,\r\n    UP: 38,\r\n    RIGHT: 39,\r\n    DOWN: 40,\r\n    A: 65,\r\n    B: 66,\r\n    C: 67,\r\n    D: 68,\r\n    E: 69,\r\n    F: 70,\r\n    G: 71,\r\n    H: 72,\r\n    I: 73,\r\n    J: 74,\r\n    K: 75,\r\n    L: 76,\r\n    M: 77,\r\n    N: 78,\r\n    O: 79,\r\n    P: 80,\r\n    Q: 81,\r\n    R: 82,\r\n    S: 83,\r\n    T: 84,\r\n    U: 85,\r\n    V: 86,\r\n    W: 87,\r\n    X: 88,\r\n    Y: 89,\r\n    Z: 90\r\n}\r\n\r\nconst mouseWorldPosition = () => mPosition.add(sceneCtrl.getScene().camera.position)\r\n\r\nexport default {\r\n    keyDown,\r\n    keyUp,\r\n    keyPressed,\r\n    clearKeys,\r\n    keyCode,\r\n    mouse,\r\n    mouseUp,\r\n    mouseDown,\r\n    mousePressed,\r\n    mousePosition,\r\n    mouseWorldPosition,\r\n    keyString: (str) => {\r\n        if (str !== undefined) {\r\n            keyString = str.split('')\r\n            return str\r\n        } else {\r\n            return keyString.join('')\r\n        }\r\n    },\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/input.js\n// module id = 9\n// module chunks = 0","import {scene, vec2} from '../../canvasEngine/engine'\r\nimport circuitGraphic from '../graphics/circuitGraphic'\r\nimport uiController from '../ui/uiController'\r\nimport sprites from '../sprites'\r\nimport createCircuit from '../model/circuit'\r\nimport util from '../../canvasEngine/util'\r\n\r\nexport default scene({\r\n    width: 400,\r\n    height: 400,\r\n    bgColor: 'black',\r\n    layers: {\r\n        BACKGROUND: 0,\r\n        TILE: 1,\r\n        MACHINE: 4,\r\n        MACHINE_TEXT: 5,\r\n        PORT: 3,\r\n        PORT_TEXT: 4,\r\n        DATA: 6,\r\n        DATA_TEXT: 7,\r\n        UI: 8,\r\n        UI_TEXT: 9\r\n    },\r\n    onInit() {\r\n        let cg = circuitGraphic(40, 20)\r\n\r\n        let uiCtrl = uiController({\r\n            circuitGraphic: cg\r\n        })\r\n\r\n        let circuit = cg.circuit\r\n\r\n        window.c = circuit\r\n\r\n        let inputData = []\r\n\r\n        for (let i = 0; i < 10; i++) {\r\n            inputData.push(util.randomInt(0, 20))\r\n        }\r\n\r\n\r\n        uiCtrl.defineMachine({\r\n            name: 'input',\r\n            inPortsAmount: 0,\r\n            outPortsAmount: 1,\r\n            processFunc (oldState, inPorts, outPorts, machine, circuit) {\r\n                if (machine.isProcessing) {\r\n                    return false\r\n                }\r\n\r\n                let inputData = circuit.getInputData(oldState, this.index)\r\n                let changedData = inputData.slice()\r\n                let result = changedData.pop()\r\n                if (result === null || result === undefined) {\r\n                    return false\r\n                }\r\n                circuit.setInputData(changedData, this.index)\r\n                circuit.createDataAt(outPorts[0], result)\r\n                machine.isProcessing = true\r\n            },\r\n            sprite: sprites.inputMachine,\r\n            onInit: (machine, c) => {\r\n                machine.index = c.inputMachineCount\r\n                c.setInputData(inputData, c.inputMachineCount++)\r\n                c.inputMachines.push(machine)\r\n                machine.isProcessing = false\r\n            }\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'output',\r\n            inPortsAmount: 1,\r\n            outPortsAmount: 0,\r\n            processFunc (oldState, inPorts, outPorts, machine, circuit) {\r\n                let outputData = circuit.getOutputData(oldState, this.index)\r\n                let changedData = outputData.slice()\r\n                changedData.push(circuit.getDataAt(inPorts[0], oldState))\r\n                circuit.setOutputData(changedData, this.index)\r\n                console.log(changedData)\r\n            },\r\n            sprite: sprites.outputMachine,\r\n            onInit: (machine, c) => {\r\n                machine.index = c.outputMachineCount\r\n                c.setOutputData([], c.outputMachineCount++)\r\n            }\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'summator',\r\n            inPortsAmount: 2,\r\n            outPortsAmount: 1,\r\n            processFunc: (oldState, inPorts, outPorts, machine, circuit) => {\r\n                let sum = circuit.getDataAt(inPorts[0], oldState) +\r\n                    circuit.getDataAt(inPorts[1], oldState)\r\n                circuit.createDataAt(outPorts[0], sum)\r\n            },\r\n            sprite: sprites.summatorMachine\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'subtractor',\r\n            inPortsAmount: 2,\r\n            outPortsAmount: 1,\r\n            processFunc: (oldState, inPorts, outPorts, machine, circuit) => {\r\n                let sub = circuit.getDataAt(inPorts[0], oldState) -\r\n                    circuit.getDataAt(inPorts[1], oldState)\r\n                circuit.createDataAt(outPorts[0], sub)\r\n            },\r\n            sprite: sprites.subtractorMachine\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'repeater',\r\n            inPortsAmount: 1,\r\n            outPortsAmount: 2,\r\n            processFunc: (oldState, inPorts, outPorts, machine, circuit) => {\r\n                let data = circuit.getDataAt(inPorts[0], oldState)\r\n                circuit.createDataAt(outPorts[0], data)\r\n                circuit.createDataAt(outPorts[1], data)\r\n            },\r\n            sprite: sprites.repeaterMachine\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'increment',\r\n            inPortsAmount: 1,\r\n            outPortsAmount: 1,\r\n            processFunc: (oldState, inPorts, outPorts, machine, circuit) => {\r\n                let data = circuit.getDataAt(inPorts[0], oldState) + 1\r\n                circuit.createDataAt(outPorts[0], data)\r\n            },\r\n            sprite: sprites.incrementMachine\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'decrement',\r\n            inPortsAmount: 1,\r\n            outPortsAmount: 1,\r\n            processFunc: (oldState, inPorts, outPorts, machine, circuit) => {\r\n                let data = circuit.getDataAt(inPorts[0], oldState) - 1\r\n                circuit.createDataAt(outPorts[0], data)\r\n            },\r\n            sprite: sprites.decrementMachine\r\n        })\r\n        uiCtrl.defineMachine({\r\n            name: 'memory',\r\n            inPortsAmount: 1,\r\n            outPortsAmount: 1,\r\n            processFunc: (oldState, inPorts, outPorts, machine, circuit) => {\r\n                if (!machine.memory) {\r\n                    machine.memory = circuit.getDataAt(inPorts[0], oldState)\r\n                } else {\r\n                    circuit.createDataAt(outPorts[0], machine.memory)\r\n                }\r\n            },\r\n            sprite: sprites.memoryMachine\r\n        })\r\n\r\n        this.camera.position = vec2(-100, -100)\r\n    }\r\n})\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/scenes/test.js\n// module id = 10\n// module chunks = 0","import util from './util'\r\nimport sceneCtrl from './sceneCtrl'\r\n\r\nconst entity = (state) => {\r\n    util.compose(state, [], {\r\n        position: util.vec2(),\r\n        angle: 0,\r\n        name: 'default',\r\n        onInit: () => {},\r\n        onUpdate: () => console.log(`${state.name} updating...`),\r\n        onDisable: () => {},\r\n        onEnable: () => {}\r\n    })\r\n    let index = sceneCtrl.getScene().entities.push(state)\r\n    state.destroy = () => sceneCtrl.getScene().entities.remove(index)\r\n\r\n    state.enabled = true\r\n    state.disable = () => {\r\n        state.onDisable()\r\n        state.enabled = false\r\n    }\r\n    state.enable = () => {\r\n        state.onEnable()\r\n        state.enabled = true\r\n    }\r\n    state.onInit()\r\n    return state\r\n}\r\n\r\nexport default entity\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/entity.js\n// module id = 11\n// module chunks = 0","import sceneCtrl from './sceneCtrl'\r\nimport canvas from './canvas'\r\nimport input from './input'\r\nimport resources from './resources'\r\nimport coroutineCtrl from './coroutineCtrl'\r\n\r\nlet running = false\r\n\r\nconst run = () => {\r\n    sceneCtrl.runScene()\r\n    coroutineCtrl.executeCoroutines()\r\n    canvas.executeDrawQueue()\r\n    input.clearKeys()\r\n    canvas.clearDrawQueue()\r\n    requestAnimationFrame(run)\r\n}\r\n\r\nresources.resourcesLoadedEvent.subscribe(() => {\r\n    console.log('Engine starting')\r\n    running = true\r\n    run()\r\n})\r\n\r\nconst isRunning = () => running\r\n\r\nexport default {\r\n    isRunning\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/gameLoop.js\n// module id = 12\n// module chunks = 0","import {getScene} from './engine'\r\n\r\nconst pointInside = (ent, point) => {\r\n    if (!ent.enabled) {\r\n        return false\r\n    }\r\n    if (ent.collider.GUI) {\r\n        point = point.sub(getScene().camera.position)\r\n    }\r\n    return !(\r\n        point.x > ent.position.x + ent.collider.rect.right + ent.collider.offset.x ||\r\n        point.x < ent.position.x + ent.collider.rect.left + ent.collider.offset.x ||\r\n        point.y > ent.position.y + ent.collider.rect.bottom + ent.collider.offset.y ||\r\n        point.y < ent.position.y + ent.collider.rect.top + ent.collider.offset.y\r\n    )\r\n}\r\n\r\nconst collisionAtPoint = (point, cond) => {\r\n    let coll = null\r\n    let entities = getScene().entities\r\n    entities.find(e => {\r\n        if (cond(e) && pointInside(e, point)) {\r\n            coll = e\r\n            return true\r\n        }\r\n    })\r\n    return coll\r\n}\r\n\r\nexport default {\r\n    pointInside,\r\n    collisionAtPoint\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/canvasEngine/physics.js\n// module id = 13\n// module chunks = 0","import {setScene} from './canvasEngine/engine'\r\nimport testScene from './resources/scenes/test'\r\n\r\nsetScene(testScene)\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/index.js\n// module id = 14\n// module chunks = 0","/*global constants*/\r\n\r\nimport {\r\n    vec2,\r\n    entity,\r\n    input,\r\n    drawSprite,\r\n    getScene,\r\n    startCoroutine,\r\n    stopCoroutine,\r\n    drawText,\r\n} from '../../canvasEngine/engine'\r\nimport circuit from '../model/circuit'\r\nimport sprites from '../sprites'\r\n\r\nwindow.constants = {\r\n    TILE_SIZE: 64\r\n}\r\n\r\nconst circuitGraphic = (width, height) => {\r\n    let c = circuit(width, height)\r\n    let portGraphics = new Map()\r\n    let machineGraphics = new Map()\r\n    let dataGraphics = new Map()\r\n\r\n    const cg = entity({\r\n        position: vec2(),\r\n        portGraphics,\r\n        machineGraphics,\r\n        dataGraphics,\r\n        circuit: c,\r\n        onUpdate() {\r\n            if (input.keyDown(input.keyCode.RIGHT)) {\r\n                c.stepForward()\r\n            }\r\n            if (input.keyDown(input.keyCode.LEFT)) {\r\n                c.stepBackward()\r\n            }\r\n            drawSprite({\r\n                position: this.position.sub(vec2(32, 32)),\r\n                sprite: sprites.grid\r\n            })\r\n        }\r\n    })\r\n\r\n    c.onMachineCreated.subscribe((m) => {\r\n        let e = entity({\r\n            spriteLayer: getScene().layers.MACHINE,\r\n            position: vec2(m.tile.x*constants.TILE_SIZE, m.tile.y*constants.TILE_SIZE),\r\n            angle: m.angle,\r\n            name: 'machine',\r\n            onUpdate() {\r\n                drawSprite({\r\n                    sprite: m.sprite,\r\n                    position: cg.position.add(this.position),\r\n                    angle: this.angle,\r\n                    layer: this.spriteLayer\r\n                })\r\n            }\r\n        })\r\n        machineGraphics.set(m, e)\r\n    })\r\n\r\n    c.onMachineDeleted.subscribe((m) => {\r\n        let graphic = machineGraphics.get(m)\r\n        graphic.destroy()\r\n    })\r\n\r\n    c.onPortCreated.subscribe((p) => {\r\n        let e = entity({\r\n            spriteLayer: 2,\r\n            position: vec2(p.tile.x*constants.TILE_SIZE, p.tile.y*constants.TILE_SIZE),\r\n            angle: p.angle,\r\n            name: 'port',\r\n            onUpdate() {\r\n                if (!p.tile.machine) {\r\n                    drawSprite({\r\n                        sprite: sprites.wireStraight,\r\n                        position: cg.position.add(this.position),\r\n                        angle: this.angle,\r\n                        layer: getScene().layers.PORT\r\n                    })\r\n                }    \r\n            }\r\n        })\r\n        portGraphics.set(p, e)\r\n    })\r\n\r\n    c.onPortDeleted.subscribe((p) => {\r\n        let graphic = portGraphics.get(p)\r\n        portGraphics.delete(p)\r\n        graphic.destroy()\r\n    })\r\n\r\n    const changeScale = (go, target, speed) => {\r\n        let pace = target.sub(go.scale).mult(1/speed)\r\n\r\n        let changeScaleCoroutine = startCoroutine(function* changeScale() {\r\n            if (go.changeScaleCoroutine) {\r\n                stopCoroutine(go.changeScaleCoroutine)\r\n            }\r\n            go.changeScaleCoroutine = changeScaleCoroutine\r\n            while (Math.abs(go.scale.x - target.x) > Math.abs(pace.x*2)) {\r\n                go.scale = go.scale.add(pace)\r\n                yield\r\n            }\r\n            go.scale = target\r\n            go.changeScaleCoroutine = null\r\n            if (go.scale.x <= 0) {\r\n                go.destroy()\r\n            }\r\n        })\r\n    }\r\n\r\n    c.onDataCreated.subscribe((p) => {\r\n        let e = entity({\r\n            spriteLayer: 3,\r\n            position: vec2(p.tile.x*constants.TILE_SIZE, p.tile.y*constants.TILE_SIZE),\r\n            angle: 0,\r\n            name: 'data',\r\n            data: c.getDataAt(p, c.getState()),\r\n            scale: vec2(0, 0),\r\n            onUpdate() {\r\n                drawSprite({\r\n                    sprite: sprites.data,\r\n                    position: cg.position.add(this.position),\r\n                    angle: this.angle,\r\n                    scale: this.scale,\r\n                    layer: getScene().layers.DATA\r\n                })\r\n                drawText({\r\n                    text: this.data,\r\n                    position: this.position,\r\n                    fontSize: 20,\r\n                    font: 'Arial',\r\n                    color: 'white',\r\n                    layer: getScene().layers.DATA_TEXT,\r\n                    scale: this.scale\r\n                })\r\n            }\r\n        })\r\n        dataGraphics.set(p, e)\r\n\r\n        changeScale(e, vec2(1, 1), 20)\r\n    })\r\n\r\n    c.onDataDeleted.subscribe((p) => {\r\n        let graphic = dataGraphics.get(p)\r\n        graphic.scaleSpeed = null\r\n        graphic.targetScale = vec2()\r\n        dataGraphics.delete(p)\r\n\r\n        changeScale(graphic, vec2(0, 0), 20)\r\n    })\r\n\r\n    const moveTo = (go, position, speed) => {\r\n        let moveCoroutine = startCoroutine(function* moveTo() {\r\n            if (go.moveCoroutine) {\r\n                stopCoroutine(go.moveCoroutine)\r\n            }\r\n            go.moveCoroutine = moveCoroutine\r\n            let velocity = position.sub(go.position).mult(1/speed)\r\n            let velocityLen = Math.abs(velocity.len()*2)\r\n            while (Math.abs(position.sub(go.position).len()) > velocityLen) {\r\n                go.position = go.position.add(velocity)\r\n                yield\r\n            }\r\n            go.position = position\r\n            go.moveCoroutine = null\r\n        })\r\n    }\r\n\r\n    c.onDataTransfer.subscribe((from, to) => {\r\n        let graphic = dataGraphics.get(from)\r\n        dataGraphics.delete(from)\r\n        dataGraphics.set(to, graphic)\r\n\r\n        let toGraphic = portGraphics.get(to)\r\n        moveTo(graphic, toGraphic.position, 20)\r\n    })\r\n\r\n    return cg\r\n}\r\n\r\nexport default circuitGraphic\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/graphics/circuitGraphic.js\n// module id = 15\n// module chunks = 0","import {entity, vec2} from '../../canvasEngine/engine'\r\n\r\nconst menu = (state = {}) => {\r\n    const menu = entity({\r\n        items: [],\r\n        interval: 10,\r\n        direction: 'row',\r\n        size: vec2(0, 0),\r\n        onUpdate() {\r\n            let offset = 0\r\n            if (this.direction === 'row') {\r\n                for (let i = 0; i < this.items.length; i++) {\r\n                    let item = this.items[i]\r\n                    item.position = vec2(this.position.x + offset + this.interval*i, this.position.y)\r\n\r\n                    offset += item.sprite.image.width\r\n                }\r\n            } else {\r\n                for (let i = 0; i < this.items.length; i++) {\r\n                    let item = this.items[i]\r\n                    item.position = vec2(this.position.x, this.position.y + offset + this.interval*i)\r\n\r\n                    offset += item.sprite.image.height\r\n                }\r\n            }\r\n        },\r\n        onDisable() {\r\n            this.items.forEach(item => item.disable())\r\n        },\r\n        onEnable() {\r\n            this.items.forEach(item => item.enable())\r\n        }\r\n    })\r\n    Object.assign(menu, state)\r\n    return menu\r\n}\r\n\r\nexport default menu\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/ui/buttonMenu.js\n// module id = 16\n// module chunks = 0","import {\r\n    entity,\r\n    input,\r\n    pointInside,\r\n    drawSprite,\r\n    rect,\r\n    vec2,\r\n    getScene\r\n} from '../../canvasEngine/engine'\r\nimport button from './button'\r\nimport sprites from '../sprites'\r\nimport textArea from './textarea'\r\n\r\nconst dialog = (state = {}) => {\r\n    let textInput = textArea()\r\n    let buttonAccept = button({\r\n        sprite: sprites.dialogButton,\r\n        text: 'OK',\r\n        offset: vec2(48, 16),\r\n        color: 'white'\r\n    })\r\n    let buttonDecline = button({\r\n        sprite: sprites.dialogButton,\r\n        text: 'Cancel',\r\n        offset: vec2(48, 16),\r\n        color: 'white'\r\n    })\r\n    let finalState = Object.assign({\r\n        textInput: textInput,\r\n        onUpdate() {\r\n            drawSprite({\r\n                sprite: sprites.dialog,\r\n                position: this.position,\r\n                GUI: true,\r\n                layer: getScene().layers.UI\r\n            })\r\n            buttonAccept.position = this.position.add(vec2(32, 196))\r\n            buttonDecline.position = this.position.add(vec2(196, 196))\r\n            textInput.position = this.position.add(vec2(64, 96))\r\n        },\r\n        onDisable() {\r\n            buttonAccept.disable()\r\n            buttonDecline.disable()\r\n            textInput.disable()\r\n        },\r\n        onEnable() {\r\n            buttonAccept.enable()\r\n            buttonDecline.enable()\r\n            textInput.enable()\r\n        },\r\n        collider: {\r\n            rect: rect(0, 0, 320, 256),\r\n            GUI: true,\r\n            offset: vec2()\r\n        },\r\n        GUI: true,\r\n        onAccept() {},\r\n        onDecline() {}\r\n    }, state)\r\n\r\n    let result = entity(finalState)\r\n\r\n    buttonAccept.onClick = result.onAccept\r\n    buttonDecline.onClick = result.onDecline\r\n    return result\r\n}\r\n\r\nexport default dialog\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/ui/dialog.js\n// module id = 17\n// module chunks = 0","import {\r\n    entity,\r\n    input,\r\n    pointInside,\r\n    drawSprite,\r\n    rect,\r\n    vec2,\r\n    drawText,\r\n    getScene\r\n} from '../../canvasEngine/engine'\r\nimport button from './button'\r\nimport sprites from '../sprites'\r\n\r\nconst textArea = (state = {}) => {\r\n    let result = entity({\r\n        text: '',\r\n        onInit() {\r\n            input.keyString('')\r\n        },\r\n        onEnable() {\r\n            input.keyString('')\r\n        },\r\n        maxLength: 10,\r\n        onUpdate() {\r\n            this.text = input.keyString()\r\n            if (this.text.length > this.maxLength) {\r\n                let textArray = this.text.split('')\r\n                textArray.length = this.maxLength\r\n                this.text = textArray.join('')\r\n                input.keyString(this.text)\r\n            }\r\n            drawSprite({\r\n                sprite: sprites.dialogInput,\r\n                position: this.position,\r\n                GUI: true,\r\n                layer: getScene().layers.UI\r\n            })\r\n            drawText({\r\n                text: this.text,\r\n                position: this.position.add(vec2(96, 16)),\r\n                GUI: true,\r\n                fontSize: 20,\r\n                layer: getScene().layers.UI_TEXT,\r\n            })\r\n        }\r\n    })\r\n    Object.assign(result, state)\r\n    return result\r\n}\r\n\r\nexport default textArea\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/ui/textarea.js\n// module id = 18\n// module chunks = 0","/*global constants*/\r\n\r\nimport {\r\n    vec2,\r\n    entity,\r\n    getScene,\r\n    input,\r\n    collisionAtPoint,\r\n    drawSprite\r\n} from '../../canvasEngine/engine'\r\nimport button from './button'\r\nimport buttonMenu from './buttonMenu'\r\nimport sprites from '../sprites'\r\nimport dialog from './dialog'\r\nimport createCircuit from '../model/circuit'\r\n\r\nconst ctrlMode = {\r\n    NONE: 0,\r\n    WIRE: 1,\r\n    DELETE: 2,\r\n    MACHINE: 3,\r\n    SAVE: 4\r\n}\r\n\r\nlet phantomMachine = {\r\n    name: null,\r\n    sprite: null,\r\n    angle: 0\r\n}\r\n\r\nlet wireAngle = null\r\n\r\nlet isBuildMode = true\r\n\r\nconst uiController = (state = {}) => {\r\n    let currentlyPlaying\r\n    const camera = getScene().camera\r\n\r\n    let savedMachines = {}\r\n\r\n    let saveDialog = dialog({\r\n        position: camera.position.add(camera.size.mult(1/2).sub(vec2(160, 128))),\r\n        onInit() {\r\n            this.disable()\r\n        },\r\n        onAccept() {\r\n            let save = circuit.save()\r\n            save.inPortsAmount = circuit.inputMachineCount\r\n            save.outPortsAmount = circuit.outputMachineCount\r\n            savedMachines[saveDialog.textInput.text] = save\r\n\r\n            if (\r\n                (save.ports.length > 0 || save.machines.length > 0) &&\r\n                circuit.outputMachineCount && circuit.inputMachineCount\r\n            ) {\r\n                localStorage.setItem('savedMachines', JSON.stringify(savedMachines))\r\n                saveDialog.disable()\r\n                ctrl.mode = ctrlMode.NONE\r\n                ctrl.defineMachine({\r\n                    name: saveDialog.textInput.text,\r\n                    inPortsAmount: circuit.inputMachineCount,\r\n                    outPortsAmount: circuit.outputMachineCount,\r\n                    sprite: sprites.incrementMachine,\r\n                    onInit(machine) {\r\n                        machine.customCircuit = createCircuit(40, 20)\r\n                        machine.customCircuit.machineTypes = circuit.machineTypes\r\n                        let loadCircuit = JSON.parse(localStorage.getItem('savedMachines'))[saveDialog.textInput.text]\r\n                        machine.customCircuit.load(loadCircuit)\r\n                    },\r\n                    processFunc(oldState, inPorts, outPorts, machine, circuit) {\r\n                        let inputData = []\r\n                        inPorts.forEach(p => inputData.push(circuit.getDataAt(p, oldState)))\r\n                        let outputData = machine.customCircuit.fullCycle(inputData)\r\n                        outputData.forEach((d, i) => circuit.createDataAt(outPorts[i], d))\r\n                    }\r\n                })\r\n            }\r\n        },\r\n        onDecline() {\r\n            saveDialog.disable()\r\n            ctrl.mode = ctrlMode.NONE\r\n        }\r\n    })\r\n\r\n    let ctrl = {\r\n        prevMousePosition: input.mousePosition(),\r\n        saveButton: button({\r\n            name: 'save',\r\n            sprite: sprites.buttonSave,\r\n            position: vec2(64, 0),\r\n            GUI: true,\r\n            onClick() {\r\n                saveDialog.enable()\r\n                ctrl.mode = ctrlMode.SAVE\r\n            }\r\n        }),\r\n        playButton: button({\r\n            name: 'play',\r\n            sprite: sprites.buttonPlay,\r\n            position: vec2(0, 0),\r\n            onClick() {\r\n                if (isBuildMode) {\r\n                    currentlyPlaying = setInterval(\r\n                        ctrl.circuitGraphic.circuit.stepForward,\r\n                        333\r\n                    )\r\n                    this.sprite = sprites.buttonStop\r\n                    isBuildMode = false\r\n                    ctrl.menuPlay.enable()\r\n                    ctrl.menuBuild.disable()\r\n                    ctrl.menuMachines.disable()\r\n                    ctrl.mode = ctrlMode.NONE\r\n                } else {\r\n                    clearInterval(currentlyPlaying)\r\n                    currentlyPlaying = null\r\n                    this.sprite = sprites.buttonPlay\r\n                    isBuildMode = true\r\n                    ctrl.menuPlay.disable()\r\n                    ctrl.menuBuild.enable()\r\n                    ctrl.menuMachines.enable()\r\n                    ctrl.circuitGraphic.circuit.reset()\r\n                }\r\n            },\r\n            GUI: true\r\n        }),\r\n        menuPlay: buttonMenu({\r\n            direction: 'row',\r\n            position: vec2(620, 0),\r\n            items: [\r\n                button({\r\n                    name: 'pause',\r\n                    sprite: sprites.buttonPause,\r\n                    position: vec2(constants.TILE_SIZE, 0),\r\n                    onClick() {\r\n                        if (currentlyPlaying) {\r\n                            clearInterval(currentlyPlaying)\r\n                            currentlyPlaying = null\r\n                            this.sprite = sprites.buttonPlay\r\n                        } else {\r\n                            this.sprite = sprites.buttonPause\r\n                            currentlyPlaying = setInterval(\r\n                                ctrl.circuitGraphic.circuit.stepForward,\r\n                                333\r\n                            )\r\n                        }\r\n                    },\r\n                    enabled: false,\r\n                    GUI: true\r\n                }),\r\n                button({\r\n                    name: 'previous',\r\n                    sprite: sprites.buttonPrevious,\r\n                    position: vec2(196, 0),\r\n                    onClick() {\r\n                        if (currentlyPlaying) {\r\n                            clearInterval(currentlyPlaying)\r\n                            currentlyPlaying = null\r\n                            ctrl.menuPlay.items[0].sprite = sprites.buttonPlay\r\n                        }\r\n                        ctrl.circuitGraphic.circuit.stepBackward()\r\n                    },\r\n                    enabled: false,\r\n                    GUI: true\r\n                }),\r\n                button({\r\n                    name: 'next',\r\n                    sprite: sprites.buttonNext,\r\n                    position: vec2(260, 0),\r\n                    onClick() {\r\n                        if (currentlyPlaying) {\r\n                            clearInterval(currentlyPlaying)\r\n                            currentlyPlaying = null\r\n                            ctrl.menuPlay.items[0].sprite = sprites.buttonPlay\r\n                        }\r\n                        ctrl.circuitGraphic.circuit.stepForward()\r\n                    },\r\n                    enabled: false,\r\n                    GUI: true\r\n                })\r\n            ],\r\n            interval: 0\r\n        }),\r\n        menuBuild: buttonMenu({\r\n            position: vec2(getScene().camera.size.x - 128, 0),\r\n            direction: 'row',\r\n            interval: 0,\r\n            items: [\r\n                button({\r\n                    name: 'wire',\r\n                    sprite: sprites.buttonWire,\r\n                    position: vec2(388, 0),\r\n                    onClick() {\r\n                        ctrl.mode = ctrlMode.WIRE\r\n                        wireAngle = null\r\n                    },\r\n                    GUI: true\r\n                }),\r\n                button({\r\n                    name: 'delete',\r\n                    sprite: sprites.buttonDelete,\r\n                    position: vec2(452, 0),\r\n                    onClick() {\r\n                        ctrl.mode = ctrlMode.DELETE\r\n                    },\r\n                    GUI: true\r\n                })\r\n            ]\r\n        }),\r\n        startPosition: vec2(),\r\n        mode: ctrlMode.NONE,\r\n        onUpdate() {\r\n            let mouseDiff = this.prevMousePosition.sub(input.mousePosition())\r\n            if (input.mousePressed(1)) {\r\n                camera.position.translate(mouseDiff)\r\n            }\r\n\r\n            this.prevMousePosition = input.mousePosition()\r\n\r\n            var cameraMoveSpeed = 10\r\n\r\n            if (this.mode !== ctrlMode.SAVE) {\r\n                if (input.keyPressed(input.keyCode.A)) {\r\n                    camera.position.translate(vec2(-cameraMoveSpeed, 0))\r\n                }\r\n                if (input.keyPressed(input.keyCode.D)) {\r\n                    camera.position.translate(vec2(cameraMoveSpeed, 0))\r\n                }\r\n                if (input.keyPressed(input.keyCode.W)) {\r\n                    camera.position.translate(vec2(0, -cameraMoveSpeed))\r\n                }\r\n                if (input.keyPressed(input.keyCode.S)) {\r\n                    camera.position.translate(vec2(0, cameraMoveSpeed))\r\n                }\r\n            }\r\n\r\n            if (!mouseOnGUI()) {\r\n                if (input.mouseDown(2)) {\r\n                    this.mode = ctrlMode.NONE\r\n                }\r\n                let mousePosition = input.mouseWorldPosition().mult(1/constants.TILE_SIZE)\r\n                let tile = this.circuitGraphic.circuit.getTileAt(\r\n                    Math.round(mousePosition.x),\r\n                    Math.round(mousePosition.y)\r\n                )\r\n                if (this.mode !== ctrlMode.MACHINE && tile) {\r\n                    drawSprite({\r\n                        sprite: sprites.selectRect,\r\n                        position: vec2(tile.x, tile.y).mult(constants.TILE_SIZE),\r\n                    })\r\n                }\r\n                switch (this.mode) {\r\n                    case ctrlMode.WIRE: {\r\n                        placeDownWires()\r\n                    } break\r\n                    case ctrlMode.DELETE: {\r\n                        deleteWiresAndMachines(0)\r\n                    } break\r\n                    case ctrlMode.NONE: {\r\n                        //\r\n                    } break\r\n                    case ctrlMode.MACHINE: {\r\n                        if (input.keyUp(input.keyCode.R)) {\r\n                            phantomMachine.angle += 90\r\n                        }\r\n                        let position = input.mouseWorldPosition().mult(1/constants.TILE_SIZE).round()\r\n                        drawSprite({\r\n                            alpha: 0.5,\r\n                            sprite: phantomMachine.sprite,\r\n                            position: position.mult(constants.TILE_SIZE),\r\n                            angle: phantomMachine.angle\r\n                        })\r\n                        if (input.mouseDown(0)) {\r\n                            circuit.createMachine(position.x, position.y, phantomMachine.angle, phantomMachine.name)\r\n                        }\r\n                    } break\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Object.assign(ctrl, state)\r\n\r\n    const machineButtons = []\r\n\r\n    ctrl.menuMachines = buttonMenu({\r\n        direction: 'column',\r\n        position: vec2(getScene().camera.size.x - constants.TILE_SIZE*2, constants.TILE_SIZE),\r\n        items: machineButtons,\r\n        interval: 0\r\n    })\r\n\r\n    const circuit = ctrl.circuitGraphic.circuit\r\n\r\n    ctrl.defineMachine = (params) => {\r\n        circuit.defineMachine(params)\r\n        machineButtons.push(button({\r\n            name: params.name,\r\n            sprite: sprites.buttonEmpty,\r\n            onClick() {\r\n                phantomMachine.angle = 0\r\n                ctrl.mode = ctrlMode.MACHINE\r\n                phantomMachine.sprite = params.sprite\r\n                phantomMachine.name = params.name\r\n            },\r\n            text: params.name,\r\n            GUI: true,\r\n            color: 'white',\r\n            offset: vec2(constants.TILE_SIZE, constants.TILE_SIZE/2)\r\n        }))\r\n    }\r\n\r\n    ctrl.onInit = () => {\r\n        let json = localStorage.savedMachines\r\n        if (!json) {\r\n            return\r\n        }\r\n        savedMachines = JSON.parse(json)\r\n        for (let key in savedMachines) {\r\n            if (savedMachines.hasOwnProperty(key)) {\r\n                let m = savedMachines[key]\r\n                ctrl.defineMachine({\r\n                    name: key,\r\n                    inPortsAmount: m.inPortsAmount,\r\n                    outPortsAmount: m.outPortsAmount,\r\n                    onInit(machine) {\r\n                        machine.customCircuit = createCircuit(20, 20)\r\n                        machine.customCircuit.machineTypes = circuit.machineTypes\r\n                        machine.customCircuit.load(m)\r\n                    },\r\n                    processFunc(oldState, inPorts, outPorts, machine, circuit) {\r\n                        let inputData = []\r\n                        inPorts.forEach(p => inputData.push(circuit.getDataAt(p, oldState)))\r\n                        let outputData = machine.customCircuit.fullCycle(inputData)\r\n                        outputData.forEach((d, i) => circuit.createDataAt(outPorts[i], d))\r\n                    },\r\n                    sprite: sprites.incrementMachine\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    function mouseOnGUI() {\r\n        return collisionAtPoint(input.mouseWorldPosition(), (e) => e.GUI)\r\n    }\r\n    function cyclePlacementPositionsLine(startPos, endPos, fn, overrideDirection) {\r\n        let horizDiff = endPos.x - startPos.x\r\n        let vertDiff = endPos.y - startPos.y\r\n        let direction, length, start, end\r\n        if (Math.abs(horizDiff) >= Math.abs(vertDiff)) {\r\n            length = Math.round(startPos.y)\r\n            direction = horizDiff >= 0 ? 0 : 180\r\n            start = Math.min(startPos.x, endPos.x)\r\n            end = Math.max(startPos.x, endPos.x)\r\n        } else {\r\n            length = Math.round(startPos.x)\r\n            direction = vertDiff >= 0 ? 270 : 90\r\n            start = Math.min(startPos.y, endPos.y)\r\n            end = Math.max(startPos.y, endPos.y)\r\n        }\r\n        for (let i = Math.round(start); i <= Math.round(end); i++) {\r\n            if (direction % 180 === 0) {\r\n                if (ctrl.circuitGraphic.circuit.getTileAt(i, length)) {\r\n                    fn(i, length, overrideDirection || direction)\r\n                }\r\n            } else {\r\n                if (ctrl.circuitGraphic.circuit.getTileAt(length, i)) {\r\n                    fn(length, i, overrideDirection || direction)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function cyclePlacementPositionsRect(startPos, endPos, fn) {\r\n        let startX = Math.min(startPos.x, endPos.x)\r\n        let endX = Math.max(startPos.x, endPos.x)\r\n        let startY = Math.min(startPos.y, endPos.y)\r\n        let endY = Math.max(startPos.y, endPos.y)\r\n        for (let i = Math.round(startX); i <= Math.round(endX); i++) {\r\n            for (let j = Math.round(startY); j <= Math.round(endY); j++) {\r\n                fn(i, j)\r\n            }\r\n        }\r\n    }\r\n    function placeDownWires() {\r\n        if (input.keyUp(input.keyCode.R)) {\r\n            if (wireAngle === null) {\r\n                wireAngle = 0\r\n            }\r\n            wireAngle += 90\r\n        }\r\n\r\n        if (input.mouseDown(0)) {\r\n            ctrl.startPosition = input.mouseWorldPosition().mult(1/constants.TILE_SIZE)\r\n        }\r\n\r\n        let endPosition = input.mouseWorldPosition().mult(1/constants.TILE_SIZE)\r\n\r\n        if (input.mousePressed(0) || input.mouseUp(0)) {\r\n            cyclePlacementPositionsLine(ctrl.startPosition, endPosition, (x, y, direction) => {\r\n                drawSprite({\r\n                    sprite: sprites.wireStraight,\r\n                    alpha: 0.5,\r\n                    angle: wireAngle || direction,\r\n                    position: vec2(x*constants.TILE_SIZE, y*constants.TILE_SIZE),\r\n                    layer: getScene().layers.UI\r\n                })\r\n            })\r\n        } else {\r\n            drawSprite({\r\n                sprite: sprites.wireStraight,\r\n                alpha: 0.5,\r\n                angle: wireAngle,\r\n                position: endPosition.round().mult(constants.TILE_SIZE),\r\n                layer: getScene().layers.UI\r\n            })\r\n        }\r\n        if (input.mouseUp(0)) {\r\n            cyclePlacementPositionsLine(ctrl.startPosition, endPosition, ctrl.circuitGraphic.circuit.createPort, wireAngle)\r\n        }\r\n    }\r\n    function deleteWiresAndMachines(mouseBtn) {\r\n        if (input.mouseDown(mouseBtn)) {\r\n            ctrl.startPosition = input.mouseWorldPosition().mult(1/constants.TILE_SIZE)\r\n        }\r\n\r\n        let endPosition = input.mouseWorldPosition().mult(1/constants.TILE_SIZE)\r\n\r\n\r\n        if (input.mousePressed(mouseBtn)) {\r\n            cyclePlacementPositionsRect(ctrl.startPosition, endPosition, (x, y) => {\r\n                drawSprite({\r\n                    sprite: sprites.deleteSign,\r\n                    alpha: 0.5,\r\n                    angle: 0,\r\n                    position: vec2(x*constants.TILE_SIZE, y*constants.TILE_SIZE),\r\n                    layer: getScene().layers.UI\r\n                })\r\n            })\r\n        } else {\r\n            drawSprite({\r\n                sprite: sprites.deleteSign,\r\n                alpha: 0.5,\r\n                angle: 0,\r\n                position: endPosition.round().mult(64),\r\n                layer: getScene().layers.UI\r\n            })\r\n        }\r\n        if (input.mouseUp(mouseBtn)) {\r\n            cyclePlacementPositionsRect(ctrl.startPosition, endPosition, (x, y) => {\r\n                circuit.deletePort(x, y)\r\n                circuit.deleteMachine(x, y)\r\n            })\r\n        }\r\n    }\r\n    return entity(ctrl)\r\n}\r\n\r\nexport default uiController\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/resources/ui/uiController.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}